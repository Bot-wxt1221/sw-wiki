
在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这一类问题近几年来反复出现在信息学的国际国内赛题中。其特点是看似并不复杂，但数据量极大，若用正常的数据结构来描述的话，往往在空间上过大，计算机无法承受；即使在空间上勉强通过，运行的时间复杂度也极高。
--《百度》










考虑到需要快速地查询和合并，为了描述一个集合，可以选取其中一个元素作为代表元，同一个集合的代表元一定相同，不同集合的代表元一定不相同。为了快速查询，通常会想到树，可以将一个集合存在一棵树上，这棵树的根节点即为代表元。 





![树](https://cdn.luogu.com.cn/upload/image_hosting/jm35cqmd.png)









对于一棵树，存储方式有很多种，并查集只涉及到查找根节点，所以只用存储每个节点的父节点（父亲表示法）。

![示例](https://cdn.luogu.com.cn/upload/image_hosting/xok5xl40.png)

上图的表示方式：
fa[1]:2
fa[2]=4
fa[3]=2
fa[4]=4(对于根节点特殊处理，遍历到这个点是即是代表元)
fa[5]=4
fa[6]=5







如何初始化：
最开始每个元素自成一个集合，故，每个元素都是代表元:
```cpp
fa[i]=i;
```




如何查询代表元：
不停地向父节点递归，找到根节点即为代表元。

```cpp
int getfa(int x){
	return fa[x]==x?x:getfa(x);
}

```


如何合并集合：
将一个集合作为另一个集合的子树
```cpp
void union(int x,int y){
	int fx=getfa(x);
	int fy=getfa(y);
	if(fx!=fy){
		fa[fx]=fy;
	}
}

```


# 优化
可见查找代表元的时间复杂度与树高相关，其实可以发现，查找的中间路径并没有用，可以优化掉，找到代表元之后，直接将这个节点的父节点变为代表元（路径压缩）
```cpp
int getfa(int n){
	return fa[n]==n?n:fa[n]=getfa(fa[n]);
}

```
1.[修复公路](https://www.luogu.com.cn/problem/P1111)

2.[口袋的天空](https://www.luogu.com.cn/problem/P1195)

树边带权值：
边合并，边维护
边压缩，边维护

1.[银河英雄传说](https://www.luogu.com.cn/problem/P1196)


在维护集合时，其实是在维护一种朋友的朋友是朋友的关系。有时候，有题目会维护敌人的敌人是朋友的关系，同样具有传递性，怎么做？
对于每个对象，维护多个元素，描述他的敌人和朋友。

1.[食物链](https://www.luogu.com.cn/problem/P2024)
